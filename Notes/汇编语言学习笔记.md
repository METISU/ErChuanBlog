# 汇编语言学习笔记
> 前端时间阅读了王爽老师的[汇编语言](https://book.douban.com/subject/25726019/)，之后一直没有抽出时间进行整理，最近终于得空，进行一个小的梳理以及回顾
## 基础知识
CPU数据的读写主要分三类

1. 存储单元的地址（地址信息）
   - 通过地址总线
2. 器件的选择，读或写的命令（控制信息）
   - 通过控制总线
3. 读或写的数据（数据信息）
   - 通过数据总线

## 寄存器
|  Register  | Conventional use |  Low 32-bits  |  Low 16-bits  |  Low 8-bits  |
|  -------------  |  -------------  |  -------------  |  -------------  |  -------------  |
|  rax  |  返回值  |  eax  |  ax  |  al  |
|  rdi  |  第一个参数  |  edi  |  di  |  dil  |
|  rsi  |  第二个参数  |  esi  |  si  |  sil  |
|  rdx  |  第三个参数  |  esx  |  dx  |  dl  |
|  rcx  |  第四个参数  |  ecx  |  cx  |  cl  |
|  r8  |  第五个参数  |  r8d  |  r8w  |  r8b  |
|  r9  |  第六个参数  |  r9d  |  r9w  |  r9b  |
|  r10  |  内部调用暂时寄存器  |  r10d  |  r10w  |  r10b  |
|  r11  |  内部调用暂时寄存器  |  r11d  |  r11w  |  r11b  |
|  rsp  |  栈指针  |  esp  |  sp  |  spl  |
|  rbx  |  临时变量  |  ebx  |  bx  |  bl  |
|  rbp  |  临时变量  |  ebp  |  bp  |  bpl  |
|  r12  |  临时变量  |  r12d  |  r12w  |  r12b  |
|  r13  |  临时变量  |  r13d  |  r13w  |  r13b  |
|  r14  |  临时变量  |  r14d  |  r14w  |  r14b  |
|  r15  |  临时变量  |  r15d  |  r15w  |  r15b  |
|  rip  |  调用寄存器  |
|  eflags  |  标志位寄存器  |

### RAX
对rax做个简单的探究

``` Objective-C
- (NSInteger)returnInt {
    return 100;
}
```

断点在函数中，在lldb中输入`finish`

![image](https://user-images.githubusercontent.com/22512175/121302709-ac379580-c92c-11eb-9f89-07f24398a1c6.png)

可见rax中存储的是100（返回值）

### rdi rsi rdx rcx r8 r9
rdi rsi rdx rcx r8 r9分别负责存储函数的第一、二、三、四、五、六个参数
``` Objective-C
- (void)argumentWithOne:(int)one two:(int)two three:(int)three four:(int)four five:(int)five six:(int)six {
    NSLog(@"test");
}
```
断点之后在lldb打印

![image](https://user-images.githubusercontent.com/22512175/121798376-84ac3a00-cc58-11eb-90b7-fd136aab676a.png)

可看到rdx rcx r8 r9分别存储了1，2，3，4

理论上rdi rsi分别存储第1、2个参数，所以看看rdi rsi分别存储了什么

![image](https://user-images.githubusercontent.com/22512175/121312219-bf9c2e00-c937-11eb-9ae7-fafc406716d6.png)

可看到rdi里面存储的是ViewController的一个对象指针，这可以理解了，OC方法消息传递，第一个参数是对象，第二个参数是SEL

![image](https://user-images.githubusercontent.com/22512175/121798381-8e35a200-cc58-11eb-8cd6-d296dd531d75.png)

### rip
rip为指令寄存器，存储下一条要执行的指令的地址

在行数首行断点

![image](https://user-images.githubusercontent.com/22512175/121800078-54699900-cc62-11eb-9aba-000ed3bdbdb0.png)

打印rip的值

![image](https://user-images.githubusercontent.com/22512175/121800407-25ecbd80-cc64-11eb-8951-8e55359f292e.png)

寻找`argumentWithOne:two:three:four:five:six:`的内存地址

![image](https://user-images.githubusercontent.com/22512175/121800423-53d20200-cc64-11eb-8453-b889a1f0d69c.png)

可看到`range = [0x000000010c76ae80-0x000000010c76aec3)`，可看到0x000000010c76ae80为rip的值

### rsp rbp
* RSP
  - 指向当前栈的顶端（由于栈向下增长，push RSP会递减，pop会递增）

* rbp
  - 一直指向栈的顶端

### 超过6个参数
前面有提到，x86共有6个寄存器用来存储参数，但是当参数超时6个的时候怎么处理呢？这边便需要用到一种常见的数据结构--**栈**

编写函数

``` Objective-c
- (void)argumentWithOne:(int)one two:(int)two three:(int)three four:(int)four five:(int)five six:(int)six seven:(int)seven eight:(int)eight nine:(int)nine ten:(int)ten {
    NSLog(@"test");
}
```

在调用处加断点

``` Objective-C
[self argumentWithOne:1 two:2 three:3 four:4 five:5 six:6 seven:7 eight:8 nine:9 ten:10];
```

打开**Debug->Debug Workflow->Always Show Disassembly**，可看到如下

![image](https://user-images.githubusercontent.com/22512175/121868306-68310000-cd33-11eb-8b65-4025bba5edea.png)

可看到前6个参数正常存储于寄存器，之后放入栈中

> 可看到入栈用的不是push操作，同时在前面可以看到`sub    rsp, 0x60`这一条指令，这是一个优化，提前给参数创造出一片空间，用来存储参数，防止多个push操作影响性能，同时12个参数（10个入参+id+SEL）正好为12\*8 = 0x60

### 函数调用栈

